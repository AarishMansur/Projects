// A custom command line shell 
#include<stdio.h>
#include<unistd.h> // Used for fork()
#include<string.h> 
#include<stdlib.h>   
#include<sys/types.h> // Used for pid_t variable 
#include<sys/wait.h> // Used for waitpid()
#include<errno.h> // Error handling 

#define LINE 1024
#define AGRS 64

int main(){
char command[LINE];
char *agrs[AGRS];
FILE *file;
file = fopen("file.txt","w");
if(file==NULL){
printf("File does not exist !!");
}
printf("myshell$");
fflush(stdout); // This removes all the buffer 
scanf("%s",command);
fprintf(file,"%s",command);
if(strcmp(command,"Exit")==0 || strcmp(command,"exit")==0){
  fclose(file);
  printf("You choose to exit.");
}
else{
  while(1){
    if(fgets(command,sizeof(command),stdin)==NULL){
      printf("\n");
      break;
    }
    if(strlen(command)==0){
      continue;
    }
    // Parsing the String into tokens 
    int i=0;
    char *token = strtok(command,"\t");
    while(token!=NULL && i<AGRS-1){
      agrs[i++] = token;
      token = strtok(NULL,"\t"); //it keeps return  next until token become null
    }
    agrs[i] = NULL; // Null terminated array  
    // Creating a child process 
   pid_t pid = fork();
   if(pid<0){
     perror("fork failed");
     continue;
   }
   else if(pid ==0){
     if(execvp(args[0],agrs)<0){
       perror("execvp failed");
       exit(EXIT_FAILURE); 
     }   
   }
   else {
     int status;
     if(waitpid(pid,&status,0)<0){
       perror("Waitpid error");
     }
   } 
  }
}
return 0;
}

